---
title: "Simulation Examples"
author:
- name: Mervin Fansler
  affiliation: MSKCC/Weill Cornell Medicine
  email: mmfansler@gmail.com
package: scutrboot
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document:
    toc: true
abstract: |
  Some simple simulation examples to illustrate the syntax of the principle functions of the package.
vignette: |
  %\VignetteIndexEntry{1. Simulation Examples}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

Many single-cell RNA sequencing technologies generate 3' end tag data capable of discerning 3' UTR isoforms of different genes.  This package provides a set of functions that can be applied to SingleCellExperiment objects that contain 3' UTR isoform UMI counts, rather than the typical gene UMI counts found in most scRNA-seq analysis tools.  Most of the tools presumes that cell types or cluster labels have already been independently identified using gene-level analysis.

## Motivation

Single-cell data is sparse, and partitioning gene counts into transcript counts aggrevates this issue.  Furthermore, one of the main measures of interest in the field of 3' UTR research is that of isoform usage frequencies, which is incalculable for most cells for low expression genes due to high zero rates.  This situation prompted us to employ bootstrapping techniques in order to characterize 3' UTR usage patterns between factorized subsets of cells.  The central idea is that given a large enough sample of cells of each type, one can resample to obtain virtual samples and use these to characterize the expected variance in the 3' UTR usage patterns of interest.

# Simulation Data
First we will make an artifical `SingleCellExperiment`, consisting of two sets of 500 cells, where we have measured for 100 genes, each with two transcripts.  We will assume the first 500 cells are in **group A** and the second in **group B**.  For the transcripts, we will assume that each gene has a short isoform (`SU`) and a long isoform (`LU`), with the transcripts ordered first by gene then by length.

```{r}
library(scutrboot)
library(SingleCellExperiment)
library(Matrix)
library(S4Vectors)

#set.seed(1231)

NCELLS = 1000
NGENES = 100
NTXS = 2*NGENES

cell.data <- DataFrame(cell=paste('cell', 1:NCELLS, sep='.'),
                       group=rep(c('A', 'B'), each=NCELLS/2))

tx.data <- DataFrame(transcript=paste('gene', rep(1:NGENES, each=2), c("SU", "LU"), sep='.'), 
                     gene=paste('gene', rep(1:NGENES, each=2), sep='.'),
                     isoform=rep(c("SU", "LU"), NGENES))

cts <- Matrix(rpois(NCELLS*NTXS, lambda=0.1), ncol=NCELLS, nrow=NTXS, sparse=TRUE,
              dimnames=list(transcript=tx.data$transcript, cell=cell.data$cell))

sce <- SingleCellExperiment(assays=list(counts=cts), colData=cell.data, rowData=tx.data)

sce
```

Given this is completely random data and we are testing 100 genes, we should expect five genes on average to come out as statistically significant at an $\alpha=0.05$ level for any tests we perform on a *per gene* basis.

## Two-Sample LU Usage Test

To efficiently run thousands of bootstraps on thousands of cells for thousands of genes, this package was implemented to perform all computations at the (sparse) matrix level. In order to properly compute on matrices, the package functions will often require indices that indicate how the matrices are organized. In this first example, we require indices for the cell groups.  For illustrative purpose we show how to do this is a way that should be easily generalized to other factors that might be of interest.

```{r luitest, results='as.is'}
idx.A <- which(sce$group == 'A')
idx.B <- which(sce$group == 'B')

idx.SU <- which(rowData(sce)$isoform == 'SU')
idx.LU <- which(rowData(sce)$isoform == 'LU')

result <- two_sample_test_lui(sce, idx.A, idx.B, idx.SU, idx.LU)

cat(sprintf("Number of genes with p-value < 0.05: %d", sum(result$pvals < 0.05)))
```

```{r luivolcano}
plot(result$B.hat - result$A.hat, -log10(result$pvals))

hist(result$pvals, breaks=20)
```

## Gene Expression Bootstrap Test

We can also test gene expression changes quite simply. First, however, we need to sum our matrix to gene counts. Since we have a column (`'gene'`) in our row data that indicates the gene to which each transcript corresponds, we can use its name in the `sum_rows_by` function to quickly compute the gene counts.  The result is then the input to the two-sample test.

```{r}
cts.genes <- sum_rows_by(sce, 'gene')

result <- two_sample_test_gene(cts.genes, idx.A, idx.B)

cat(sprintf("Number of genes with p-value < 0.05: %d", sum(result$pvals < 0.05)))
```

```{r genevolcano}
plot(log2(result$B.hat/result$A.hat), -log10(result$pvals))

hist(result$pvals, breaks=20)
```


# Style macros

_BiocStyle_ introduces the following macros for referring to _R_ packages:

* `r Biocpkg("IRanges")`, for _Bioconductor_ software, annotation and experiment data packages,
* `r CRANpkg("data.table")`, for _R_ packages available on CRAN,
* `r Githubpkg("rstudio/rmarkdown")`, for _R_ packages available on GitHub,
* `r Rpackage("MyPkg")`, for _R_ packages that are _not_ available on _Bioconductor_, CRAN or GitHub.


# Figures

Assign captions to figures in the code chunk option `fig.cap` to automatically number them, and to be able to reference them, see Figure \@ref(fig:plot). The figure label is generated from the code chunk label by prefixing it with `fig:`.

```{r plot, fig.cap="Regular figure. The first sentence of the figure caption is automatically emphasized to serve as figure title.", echo=FALSE}
plot(cars)
```

Small and wide figures can be specified by `fig.small` and `fig.wide` code chunk options.

```{r small, fig.cap="Small figure. A plot produced by a code chunk with option `fig.small = TRUE`.", fig.small=TRUE, echo=FALSE}
plot(cars)
```

```{r wide, fig.cap="Wide figure. A plot produced by a code chunk with option `fig.wide = TRUE`.", fig.wide=TRUE, echo=FALSE}
plot(cars)
```


# Equations

To number and reference equations, put them in equation environments and assign labels to them, see Equation \@ref(eq:binom).

\begin{equation}
  f\left(k\right) = \binom{n}{k} p^k\left(1-p\right)^{n-k}
  (\#eq:binom)
\end{equation}


# Tables

Like figures, tables with captions will also be numbered and can be referenced, see Table \@ref(tab:table).

Fruit   | Price
------- | -----
bananas | 1.2
apples  | 1.0
oranges | 2.5

: (\#tab:table) A simple table. With caption.


# Cross-references

Apart from referencing figures (Section \@ref(figures)), tables (Section \@ref(tables)), and equations (Section \@ref(equations)), you can also use the same syntax to refer to sections by their default labels generated by pandoc.


# Side notes

Footnotes are displayed as side notes on the right margin^[this is a side note entered as a footnote], which has the advantage that they appear close to the place where they are defined.


# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
